<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REST</title>
    <link rel="stylesheet" href="../src/style/arts_header.css">
    <link rel="stylesheet" href="../src/style/article.css">
</head>
<body>

    <header class='header'>
        
        <nav class='navbar'>
            <a href='../index.html'>Главная</a>
            <a href='../pages/articles.html'>Мои статьи</a>
            <a href='../pages/works.html'>Примеры работ</a>
        </nav>
        
        <img class='menu_btn' src="../src/icons/menu.png"/>

        <nav class='contacts'>
            <a href='../pages/autor.html'>Об авторе</a>
            <a href='https://t.me/Mark_Bogdan'><img src="../src/icons/telegram.png"/></a>
        </nav>

    </header>     
    <div class="image_background_container"></div>
    <div class="image_cover_container"></div>
<div class="article_content">
<h2>Вместо предисловия</h2>

<p>Representational State Transfer или
сокращенно – что это такое? В интернете полно
статей на разных языках. Но многие трактовки этого понятия противоречат друг
другу. Как же докопаться до сути?</p>
<br>
<p>Мне кажется,
самый простой способ – разбить любое сложное понятие на составляющие, эти
составляющие – на их составляющие, пока не дойдем до основы.</p>
<br>
<p>Еще один
неплохой вариант – изучить доступную информацию, даже если она противоречит
друг другу. Когда мы изучим несколько точек зрения, можно их сравнить,
проанализировать, выявить наиболее понравившуюся и дальше придерживаться её.</p>
<br>
<p>Для этого
придется разобрать несколько примеров. Без них никуда.</p>
<br>
<p>Пускай точка
зрения, описанная в этой статье, будет дополнением к тем знаниям, которые Вы
уже изучили, или только собираетесь. Я буду использовать как можно меньше
технических терминов – о них и без этого достаточно написано. Здесь я
постараюсь изложить свое видение основных концепций, связанных с REST, на простых примерах. В
дальнейшем при изучении технической документации процесс понимания сложных
вещей будет немного проще. И если сейчас что-то останется непонятным, всё
прояснится в дальнейшем, при изучении REST уже на
реальных примерах.</p>
<br>

<h2>Кодекс разработчика</h2>
<br>
<p>Самое
распространенное и ключевое понятие REST – это <b>стиль</b>.
Стиль взаимодействия распределённого web-приложения
(или сложного, составного приложения).</p>
<br>
<p>Давайте немного
поговорим о самом web-приложении и том, где оно
распределено. В обычной жизни приложением для нас является программа, скачанная
на телефон или планшет; программа на рабочем компьютере. Некоторые web-сайты в интернете сейчас всё чаще называют  web-версией приложения. Получается, что web-приложение – это
приложение на телефоне, планшете или сайт в интернете? Да, но зачастую это
всего лишь часть одного большого приложения, состоящего из нескольких таких
частей.</p>
<br>
<p>Давайте
разберем это на простом примере. Предположим, Вы захотели узнать погоду. Вы скачали
приложение на телефон, выбрали свой город и посмотрели погоду на неделю вперед.
Обыденная ситуация, но мало кто задумывается, что для того, чтобы это стало
возможным, пришлось построить сложную систему из элементов, взаимодействующих
между собой, – то самое сложное приложение, распределённое по сети. Приложение,
скачанное на телефон, или сайт, на котором Вы узнаете погоду, – это так
называемая клиентская часть приложения, представляющая из себя красивую
оболочку для отображения данных.</p>
<br>
<p>Сами данные
берутся из скрытой от пользователя части приложения, которую называют
серверной. Вся обработка и хранение информации происходит там. Серверная часть
приложения также может делиться на части, состоять из нескольких приложений
(серверов). Именно поэтому распределённое web-приложение и называют сложным. А
распределённым оно считается, потому что территориально его компоненты могут
находиться в абсолютно разных местах.</p>
<br>
<p>Со сложным
распределённым приложением немного разобрались. Теперь давайте разбираться со
стилем REST. Существует стиль в одежде, архитектурный
стиль, музыкальный стиль и так далее. И что между всем этим общего? В любом
стиле есть свои правила соответствия, и совокупность этих правил называют
стилем. Получается, что и REST – это совокупность
правил организации взаимодействия тех самых компонентов распределённого
приложения, о которых мы говорили выше. Что-то вроде кодекса, написанного
разработчиками для разработчиков. </p>

<br>
<br>

<p class="img_src"><img src="../src/img/art_rest/image001.jpg"></p>
<p class='img_desc'>Кодекс — это свод правил, а не жестких законов! Г.
Барбоса</p>

<br>
<br>
<p>Отлично, с
терминами мы познакомились. Осталось понять, что это за правила.</p>
<br>

<h2>Индейка в сливочном соусе.</h2>
<br>
<p>Представьте
себе, что Вы приходите в ресторан, садитесь за столик и готовитесь сделать
заказ. К Вам подходит официант, и Вы сообщаете ему, что на горячее Вы будете
индейку в сливочном соусе, на десерт пирожное с черносливом, а пить вы будете
лимонный компот. Неплохой выбор! Официант внимательно выслушивает Вас и
удаляется на кухню. Там он, в свою очередь, передаёт повару, что тот должен
приготовить для Вас жаркое из индейки, пирожное с черносливом и компот.</p>
<br>
<p>Спустя какое-то
время, официант возвращается к Вам и приносит блюда.</p>
<p>Всё это
здорово, но при чём здесь REST?
Давайте рассмотрим эту ситуацию, как будто Вы воспользовались приложением
(сложным приложением), разработанным по всем канонам REST
(далее мы будем называть его REST-системой).</p>
<br>
<p>Вы хотите что-то получить от официанта. Назовем это что-то «ресурс». Для этого вы
обращаетесь к нему, запрашивая этот ресурс. Другими словами, делаете запрос.
Если вы запрашиваете у официанта этот ресурс, значит, он у него есть. В системе
REST тот, кто запрашивает
ресурс, называется клиентом, а тот, кто имеет этот ресурс, называется сервером.</p>

<br>

<p>Получается, Вы
являетесь клиентом, официант – сервером. Вы передаете ему запрос, в котором
указываете, какую еду хотели бы сегодня отведать (получить в ответ). Представим
сам запрос в следующем формате:</p>

<br>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;горячее&quot;: &quot;индейка в сливочном соусе&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;десерт&quot;: &quot;пирожное с черносливом&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;напиток&quot;: &quot;лимонный компот&quot;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<br>
<br>
<p>Так гораздо
лучше. Передавать запрос Вы будете по <i>url-адресу</i>:</p>

<p class='adress'>http://ресторан/официант/заказ</p>

<p>Отлично! Теперь давайте коснёмся
методов передачи запросов. Методом является одно ключевое слово в начале
запроса, которое указывает, какое действие с желаемым ресурсом Вы бы хотели
произвести. В данном случае, т.к. вы ещё и сами передаёте какую-то информацию,
методом передачи запроса будет метод POST. Подробнее о
методах запроса мы поговорим чуть позже. А пока имеем запрос такого вида: </p>


<p>Адрес: <span class='adress'>http://ресторан/официант/заказ;</span></p>

<p>Метод:  POST;</p>

<p>Тело запроса: </p>

<br>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;горячее&quot;: &quot;индейка в сливочном соусе&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;десерт&quot;: &quot;пирожное с черносливом&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;напиток&quot;: &quot;лимонный компот&quot;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<br>

<p>Официант
обрабатывает данные и передаёт их повару также в виде запроса. Теперь уже
официант берёт на себя роль клиента, а повар является сервером. Давайте
представим это в виде наглядной схемы.</p>

<br>

<p class="img_src"><img src="../src/img/art_rest/image002.jpg"></p>

<br>

<p>Как мы видим,
на схеме есть клиенты и есть серверы. Тут сразу же стоит отметить, что речь
идёт о ролях компонентов системы, обращающихся друг к другу. Ни в коем случае
нельзя отождествлять понятия клиента и сервера с клиентской и серверной частью
приложения. В данном случае клиентской частью будет только посетитель
ресторана (крайний левый клиент). Все что правее – серверная часть.</p>

<br>
<p>Вот так
выглядит схема работы приложения, построенного по принципу клиент-серверной
архитектуры. А мы с вами имеем первое правило организации REST,
это <b><i><u>клиент-сервер</u></i></b>. Есть клиент, есть сервер. Они
взаимодействуют между собой путём отправки запроса и получения ответа.</p>

<br>
<p>Наверное, Вы
заметили, что на схеме присутствует еще и база данных. В сложных приложениях
так называют хранилище данных. Перед тем, как начать готовить еду, повар должен
заглянуть в холодильник и убедиться, что у него есть все необходимые продукты.
Тут холодильник будет являться базой данных, и только повар может
взаимодействовать с ней. Мы подошли ко второму правилу REST
– <b><i><u>многослойная архитектура</u></i></b>. </p>

<br>
<p>Могло оказаться
так, что в холодильнике не оказалось бы нужных продуктов. Тогда повар на запрос
официанта вернул бы вместо готового блюда свои сожаления, которые официант, в
свою очередь, передал бы Вам. Ему бы пришлось предложить что-нибудь другое,
чтобы Вы остались и сделали новый заказ. Причем, заметьте, клиент может
взаимодействовать только со своим сервером, а сервер со своим клиентом. Повар
не выйдет к Вам в гостевой зал и не сообщит информацию лично. И его абсолютно
не волнует, как дальше пойдет Ваше взаимодействие с официантом. Продуктов нет,
и всё тут. В этом и заключается такая особенность REST
как слоистая архитектура.</p>

<br>

<p>Всё-таки
предположим, что сегодня всё сложилось удачно, нужные продукты оказались в
холодильнике (базе данных), и официант вернул Вам положительный ответ в виде
горячего и компота, а не сожалений. Тут вроде бы все понятно, идем дальше.</p>

<br>

<h2>Ну и запросы у Вас …</h2>

<br>

<p>Теперь давайте
подробнее разберемся с нашими запросами, а точнее, с методами их передачи.
Придется немного пофантазировать.</p>

<br>

<p>Вы остались
довольны трапезой и решили вернуться в это заведение в следующий выходной.
Неделя пролетела очень быстро, и вот Вы снова сидите за столиком. А номер
Вашего столика, предположим, – 4. Почему бы и нет? К Вам подходит официант, и
Вы делаете заказ. Снова представим его в виде запроса:</p>

<br>

<p>Адрес: <span class="adress">http://ресторан/официант/заказ;</span></p>

<p>Метод:  POST;</p>

<p>Тело запроса: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;горячее&quot;: &quot;индейка в сливочном соусе&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;десерт&quot;: &quot;пирожное с черносливом&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;напиток&quot;: &quot;лимонный компот&quot;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<br>

<p>Теперь давайте
более детально проанализируем, что происходит дальше. Официант принимает Ваш
запрос и формирует новый запрос для отправки дальше – повару. Этот запрос уже
будет выглядеть следующим образом: </p>

<br>

<p>Адрес: <span class="adress">http://ресторан/повар/заказы;</span></p>

<p>Метод: POST;</p>

<p>Тело запроса: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;заказ для&quot;: &quot;столик №4&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;заказ&quot;:</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;горячее&quot;: &quot;индейка в сливочном соусе&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;десерт&quot;: &quot;пирожное с черносливом&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;напиток&quot;: &quot;лимонный компот&quot;</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<br><br>
<p>Особо
внимательный читатель заметит, что в конце адреса, по которому передаёт свой
запрос официант, «заказы» указаны во множественном числе. Это и правильно, ведь
посетителей ресторана много, как и заказов. Но как официанту с поваром
ориентироваться в этом многообразии? Для этого в запросе официанта добавился
еще и номер Вашего столика. Это поле будет неким идентификатором или  ID заказа. После чего будет создан некий ресурс (заказ),
доступный по адресу: </p>

<p class="adress">
http://ресторан/повар/заказы/заказ_для_столика_№4</p>

<p>Теперь все
дальнейшие манипуляции с заказом будут происходить именно по этому адресу.</p>

<br>

<p>Пока официант был на кухне, передавая данные повару, Вы
вспоминаете, что один приятель рассказывал про чудесный суп с грибами, который
подают в этом ресторане. Как только в следующий раз официант попадает в поле
зрения, Вы подзываете его к себе и сообщаете, что хотели бы добавить суп к
заказу. Тут переданный Вами запрос будет иметь следующий вид:</p>

<br>

<p>Адрес: <span class="adress">http://ресторан/официант/заказ;</span></p>

<p>Метод:  PATCH;</p>

<p>Тело запроса: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;первое блюдо&quot;: &quot;грибной суп&quot;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<br>

<p>Метод этого
запроса будет выглядеть как PATCH. Теперь будет
понятно, что к уже имеющемуся заказу нужно добавить первое блюдо. Следующим
действием официант должен донести до повара информацию о том, что Вам нужно
приготовить суп. Как это сделать? Конечно же, отправить запрос. На этот раз он
будет иметь следующий вид:</p>

<br>

<p>Адрес: <span class="adress">http://ресторан/повар/заказы/заказ_для_столика_№4;</span></p>

<p>Метод:  PATCH;</p>

<p>Тело запроса: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;первое блюдо&quot;: &quot;грибной суп&quot;,</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>


<br>

<p>Адрес отправки
запроса будет следующий: </p>

<p class="adress">http://ресторан/повар/заказы/заказ_для_столика_№4</p>

<p>Вот для чего нам нужен был  ID заказа. Когда официант будет передавать данные повару, ему
будет понятно, что речь идёт об уже имеющемся заказе для столика №4.</p>

<br>

<p>Отлично, теперь повар поймет, что ему нужно приготовить суп
и отдать его официанту, обслуживающему столик №4.</p>

<br>

<p>Повар приступил к приготовлению, но Вы немного поразмыслили
и поняли, что грибной суп — это не совсем то, чего бы Вам сегодня хотелось. Что
с гораздо большем аппетитом Вы бы съели суп с говядиной. И, пожалуй, при таком
раскладе пирожное с черносливом уже не поместится в желудке. Придётся опять
изменять заказ. Не беда, в этом заведении Вы можете себе такое позволить.
Легкий взмах рукой, и официант готов выслушать новые пожелания. В этой ситуации
придется сделать два запроса.</p>

<br>

<p>Первый – методом PATCH для изменения первого блюда: </p>

<br>

<p>Адрес: <span class="adress">http://ресторан/официант/заказ;</span></p>

<p>Метод: PATCH;</p>

<p>Тело запроса: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;первое блюдо&quot;: &quot;суп с говядиной&quot;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<br>

<p>Второй – еще не знакомым нам методом DELETE для
отмены десерта: </p>

<br>

<p>Адрес: <span class="adress">http://ресторан/официант/заказ;</span></p>

<p>Метод: DELETE;</p>

<p>Тело запроса: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;десерт&quot;: &quot;пирожное с черносливом&quot;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<br>

<p>Отлично, Вы
отказались от десерта, и перезаказали суп. Теперь Вы точно останетесь довольны
ужином.</p>

<br>

<p>Официант же
спешит на кухню сообщить повару, чтобы тот не торопился класть в суп грибы. Там
он передаст повару два запроса: </p>

<br>

<p>Первый: </p>

<p>Адрес: <span class="adress">http://ресторан/повар/заказы/заказ_для_столика_№4;</span></p>

<p>Метод: PATCH;</p>

<p>Тело запроса: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;первое блюдо&quot;: &quot;суп с говядиной&quot;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<br>

<p>Второй: </p>

<p>Адрес: <span class="adress">http://ресторан/повар/заказы/заказ_для_столика_№4;</span></p>

<p>Метод: DELETE;</p>

<p>Тело запроса: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;десерт&quot;: &quot;пирожное с черносливом&quot;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<br>

<p>Но есть и
альтернативный вариант. Тут-то и появляется на сцене новый метод –  PUT. Метод PUT может целиком заменить
уже имеющийся ресурс. В нашем случае речь идёт о заказе.</p>

<br>

<p>И так, официант
обращается по адресу:</p>

<p class="adress">http://ресторан/повар/заказы/заказ_для_столика_№4;</p>

<br>

<p>И методом  PUT передаёт запрос: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;первое блюдо&quot;: &quot;суп с говядиной&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;горячее&quot;: &quot;индейка в сливочном соусе&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;напиток&quot;: &quot;лимонный компот&quot;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<br>

<p>Отлично. Старый
заказ будет удален, а вместо него появится новый. Теперь повар поймет, что для
столика №4 ему не нужно готовить пирожное. А вместо шампиньонов в суп он
положит свежую говядину.</p>

<br>

<p>Существует
также метод GET, пример с ним мы рассмотрим чуть позже.
На самом деле методов запросов гораздо больше. Мы рассмотрели только самые
основные.</p>

<br>

<p>Что ж, и в этот
раз все блюда благополучно были доставлены. Вы остались довольны, и, конечно
же, решили вернуться сюда в следующий выходной.</p>

<br>

<p>На самом деле,
в этой главе мы рассмотрели не только методы передачи запроса, но еще и
коснулись одного из самых главных правил REST – это
правило <b><i><u>единого интерфейса.</u></i></b> Оно достойно отдельной главы,
поэтому о нём мы поговорим дальше.</p>

<br>

<h2>Один как все и все как один</h2>

<br>

<p>Итак, единый
интерфейс. В данном случае этим термином можно назвать способ взаимодействия.
Получается, дальше речь пойдет о едином способе взаимодействия. Конечно же, всё
происходит в контексте REST-взаимодействия компонентов
приложения, которыми (как мы уже говорили) являются клиент и сервер. </p>

<br>

<p>Что мы имеем
теперь? Одно из правил REST – единый интерфейс – это
правило единого способа взаимодействия компонентов приложения. А само понятие  REST – это совокупность правил организации взаимодействия тех
самых компонентов распределённого приложения. Таким образом, одно из набора
правил взаимодействия – это правило взаимодействия. Масло масляное.
Умозаключение логичное, но никакой смысловой нагрузки пока в себе не несёт.
Давайте разбираться.</p>

<br>

<p>Вернемся к
нашему вежливому официанту. Как мы уже сказали, в совокупности правил
взаимодействия REST есть отдельное правило общения,
которое так и называется – правило взаимодействия. Официант – компонент
системы? Компонент. Значит, и для него применимо это правило. Мы уже коснулись
ролей взаимодействия, зон ответственности, но еще не говорили о поведении. Да,
единый интерфейс – это что-то вроде правила поведения во время взаимодействия.
Как должен вести себя наш официант? Он должен быть учтив, внимателен, вежлив.
Он должен знать, кому и что ему можно и нужно говорить. Когда он подойдет к
Вашему столику, он предложит Вам сделать заказ. Он не начнет рассказывать о
том, как правильно играть в гольф или как готовить круассаны с клубникой. Ему
совершенно не важно, кто будет его клиентом. С любым своим клиентом он будет
взаимодействовать одинаково учтиво – выслушивать заказ, вежливо отвечать на
вопросы, приносить еду и напитки. Так же и с поваром – неважно, для какого
столика он будет готовить еду, какой официант принёс ему заказ. Повар будет
стараться приготовить одинаково для всех.</p>

<br>

<p>В этом и есть
прелесть REST. Компоненты REST-системы
стандартизированы, их можно легко заменить другими такими же компонентами.
Главное, чтобы они знали, как им взаимодействовать друг с другом. Если вдруг
посещаемость ресторана будет расти, можно увеличить количество официантов.
Правила поведения официантов везде одинаковые. Нужно только показать
новенькому, где кухня, и он готов к работе. При этом другие элементы системы
затронуты не будут и никакой работы над ними проделывать не нужно.</p>

<br>

<p>Представим еще,
что наш любимый ресторан стал предлагать такую услугу как «еда на вынос». Тут
потребуются новые компоненты – доставщики еды. Они будут общаться с клиентской
частью посредством телефонной связи или мессенджеров, но передавать заказ
повару они будут абсолютно так же, как и официанты. Отправлять запрос:</p>

<br>

<p>Адрес: <span class="adress">http://ресторан/повар/заказы;</span></p>

<p>Метод:  POST;</p>

<p>Тело запроса: </p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;заказ для&quot;: &quot;доставщик Иван Иванов&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;заказ&quot;:</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;горячее&quot;: &quot;индейка в сливочном соусе&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;десерт&quot;: &quot;пирожное с черносливом&quot;,</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;напиток&quot;: &quot;лимонный компот&quot;</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<br>

<p>Тем самым
создавая ресурс: </p>

<p class="adress">http://ресторан/повар/заказы/заказ_на_вынос_Иван_Иванов;</p>

<br>

<p>Процесс
изменения размеров системы называется <i>масштабированием</i>. Масштабирование
– это один из неотъемлемых плюсов REST-систем. В любой
момент можно легко изменить размеры серверной части в зависимости от
потребностей клиента. И во многом это благодаря правилу единого поведения.
Замечательное правило! Само оно включает четыре подправила для облегчения
работы.</p>

<br>

<p><b>Первое –
ресурсоёмкость или ресурсный подход.</b></p>

<p>Хоть у каждого
ресурса и есть свой идентификатор (<u><span style='color:#4472C4'>заказ_для_столика_№4</u>),
он должен быть включен в обобщённое понятие (<u><span style='color:#4472C4'>заказы</u>),
для того чтобы мы знали, к какой группе ресурсов относится это ресурс.</p>

<br>

<p><b>Второе –
манипуляция ресурсами посредством представлений. </b></p>

<p>Я бы даже
сказал, посредством перепредставлений, или, если быть еще точнее,
перепредоставлений. В оригинале это правило называется
Manipulation of Resources Through Representations. Сама аббревиатура  REST - Representational State Transfer.
И самое важное тут – понять, что
же это за Representations и Representational .</p>

<br>

<p> Representations переводится как «представление ». У клиента есть своё представление о ресурсе. Оно может
меняться. Как мы помним из нашего примера, мы могли несколько раз изменять свой
заказ. Для этого мы озвучивали свое представление того, как должен выглядеть
наш заказ официанту, а тот, в свою очередь, повару.</p>

<br>

<p>Тогда что же
такое Representational? В
контексте с REST, пожалуй, можно дать значение
этому слову – актуальный или наиболее точный.</p>

<p>Из чего
следует, что REST можно перевести как «передача
актуального состояния».</p>
<br>
<p>Стоит отметить
– изменять ресурс может только тот, у кого есть на это право. Официант,
обслуживающий столики № 3, 4 и 7 не может прийти к повару и изменить заказ для
столика № 1.</p>

<br>

<p><b>Третье –
информативные сообщения (абсолютно точные сообщения).</b></p>

<p>Когда клиент
обращается к серверу он должен быть абсолютно точным в своих обращениях.</p>
<br>
<p>Если за
столиком №3 кто-то закажет моккачино, официант не должен, придя к повару,
крикнуть ему: «Мне моккачино, и побыстрее!». Повар может подумать, что официант
устал, хочет выпить кофе и восполнить силы. На скорую руку он сварит не самый
лучший в его практике напиток, положит туда побольше кофе, чтобы заряда
бодрости официанту хватило на подольше. Да и еще нальет всё это в железную
большую кружку, если чистой чашки под рукой не окажется.</p>
<br>
<p>Вместо этого
официант должен прийти к повару и сказать: «Заказ для третьего столика.
Моккачино.» Вот тогда повар правильно поймёт официанта. Приготовит свой лучший
напиток и нальет его в чистую фарфоровую чашку.</p>

<br>

<p><b>Четвертое</b>
- <b>гипермедиа как движущая сила состояния приложения.</b> Hypermedia
as the Engine of Application State, или сокращенно <b>HATEOAS. </b>Об
этом правиле мы поговорим чуть позже.</p>

<br>

<h2>Официант
не был бы официантом, будь у него состояние…</h2>

<br>

<p>При каждом
визите в ресторан Ваше общение с официантом начинается с чистого листа. У Вас
не получится сказать ему: «Я буду то же, что и в прошлый раз». Официант не
запоминает, кто и что заказывал ранее. Поэтому если Вы захотите повторить свой
заказ, придется потратить немного времени и снова озвучить весь список
желаемого. Это и будет называться <b><i><u>Stateless</u></i></b><i> </i>или<b><i><u>
отсутствием состояния</u></i></b>, что, в свою очередь, является ещё одним
правилом REST. Конечно, клиенту не всегда удобно
запоминать, что он заказывал в прошлый раз. Да и времени на заказ уйдёт гораздо
больше. Но давайте вспомним о том, что официант, обычно обслуживающий Ваш
столик, хоть и добросовестный работник, но всё же человек, и может попросту
заболеть. И его заменит другой. И вот этот другой официант уже точно не будет
помнить, что Вы брали в прошлый раз. Он не станет звонить официанту, который
обслуживал Вас ранее, и узнавать о прошлом заказе. Да и телефона может не
оказаться под рукой. Гораздо проще и быстрее, если официант просто запишет Ваш
заказ и отнесёт повару, согласитесь? А если в следующий Ваш визит и этот
официант не выйдет на работу по каким-то причинам, его с лёгкостью заменит
любой другой. Это еще один критерий, благодаря которому возможно масштабирование.</p>

<br>

<p>Поскольку заказ
придется делать по-новой, Вы решили изучить меню. Ваше внимание привлек салат с
сельдереем. Подозвав официанта, Вы решили поинтересоваться составом блюда.</p>

<br>

<p>Вы снова
делаете запрос новым, но уже упоминавшимся методом GET.
В этот раз Вы не передаёте никаких данных. Выглядеть это будет примерно так:</p>

<br>

<p>Адрес: <span class="adress">http://ресторан/официант/составы блюд/салат_с_сельдереем;</span></p>

<p>Метод:  GET</p>

<br>

<p>Как видите,
здесь нет никакого тела запроса. Мы хотим получить информацию, ничего не
передав. А то, о чём мы хотим получить информацию, указываем в адресной строке.</p>

<br>

<p>Теперь
официанту нужно дать вам ответ в виде рецепта салата. Официант, к сожалению, не
знает рецепта. Он удаляется на кухню, чтобы поинтересоваться у повара – из чего
же тот готовит салат. Спустя какое-то время официант возвращает Вам ответ:</p>

<br>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </p>

    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;салат с сельдереем&quot;: &quot;курица, сельдерей, перепелиное яйцо, оливковое масло&quot;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<br><br>

<p>Такой себе
салат, не правда ли? Но о вкусах не спорят. Вы этот салат решили не заказывать,
а вот за соседнем столиком кто-то услышал про него и тоже решил
поинтересоваться у официанта, что входит в состав. Официант опять удаляется на
кухню – он уже забыл рецепт. Ох уж эта рассеянность… Но повар твердо знает,
что он кладёт в свой салат, и спустя время официант возвращается к клиенту с
рецептом. Салат с сельдереем становится всё популярнее. Теперь уже в другом
конце зала кто-то решил его заказать. И официант снова направляется на кухню,
чтобы узнать рецепт. </p>

<br>

<p>Согласитесь, не
самая лучшая ситуация? Какой же может быть выход? Рецепт салата – это
неизменяемые данные (или не так часто изменяемые), поэтому официанту было бы
неплохо запомнить его. Тогда он сможет озвучивать клиентам рецепт салата
мгновенно, не тратя свое время на походы на кухню, да и повара не будет
отвлекать. </p>

<br>

<p>Запоминание
рецепта салата в этой ситуации будет называться <b><i><u>кэшированием.</u></i></b>
Кэширование — это еще одно правило REST.</p>

<br>

<p>Отмечаем одну
особенность. Кэшировать стоит только те данные, которые точно не изменятся.
Если вдруг они поменяются, нужно перезаписать их и в кэше.</p>

<br>

<p>Вдруг у повара
не окажется курицы, и он решит заменить её рыбой. Согласитесь будет не очень
хорошо, ведь официант пообещал Вам салат с курицей.</p>

<br>

<p class="img_src"><img src="../src/img/art_rest/image003.jpg"></p>

<br>

<p>Теперь давайте
вернемся к пропущенному понятию <b>HATEOAS. </b>В любом
заведении в ответ на вопрос о составе салата официант сообщает Вам только
рецепт, и ничего более. Но в этой статье мы рассматриваем заведение, где
взаимодействие компонентов происходит согласно всем правилам REST.
И что это будет значить для Вас?</p>

<br>

<p>Когда Вы
поинтересуетесь у официанта, из чего будет приготовлен салат, он расскажет не
только сам рецепт, но и то, какое блюдо Вы можете заказать в дополнение, с
каким напитком его лучше попробовать. Кроме того, на выбор он предоставит
список блюд, которые Вы могли бы заказать, не окажись этого салата в наличии.
Или информацию о тех блюдах, о которых, по мнению официанта, Вам очень важно
было бы знать.</p>

<br>

<p>Согласно
правилу <b>HATEOAS</b>,<b> </b>сервер в ответ на запрос
возвращает не только запрошенную информацию или ресурс, но и отсылки к другим
ресурсам, чтобы клиент мог в них ориентироваться.</p>

<br>

<p>Неплохо,
правда? Теперь Вы можете заказать что-то ещё или даже изменить свой заказ.
Вроде бы это хорошее правило, но не всегда оно работает во благо. Клиент,
получив так много информации, может глубоко задуматься и потратить массу
времени на выбор блюд. Поэтому официанту стоит грамотно формулировать свой
ответ.</p>

<br>

<h2>Официант,
дичь!</h2>

<br>

<p>И снова Вы в своем любимом
ресторане. В этот раз Вы заказали не жаркое из индейки, а блюдо из дикой
куропатки. Особенность этого блюда в том, что его нужно есть с пылу с жару. Как
же этого добиться? Ведь пока официант дойдет до повара, пока принесет блюдо
Вам. А если в этот момент будет занят обслуживанием другого столика… Пройдет
много времени, всё остынет. К счастью, гении кулинарного дела придумали выход –
заливать блюдо алкоголем и поджигать. Отличное решение, но идти через весь зал
с горящей куропаткой – не самая лучшая ситуация. Хм… А ведь можно просто
снабдить официанта всем необходимым, скажем – готовым блюдом, залитым
алкоголем, и спичками. Поджечь птицу можно непосредственно в момент подачи,
скажем так, на стороне клиента.</p>

<br>

<p>Подобным образом и работает
последнее правило REST – <b><i><u>код по запросу</u></i></b><i>.</i>
Допустим, нам нужно выполнить какой-то сценарий на стороне клиента. Не
обязательно выполнять его ещё и на сервере, правда? Можно отправить код на
клиентскую часть приложения и там выполнить его. Примерно так же, как поджечь
куропатку под носом у клиента.</p>

<br>

<h2>Подведем
итоги</h2>

<br>

<p>Что ж, мы выяснили, что для
организации REST-сервиса необходимо придерживаться
следующих шести правил:</p>

<br>


<p><b>&bull; Клиент-серверная
архитектура.</b> Вы клиент, официант – сервер. Вы можете обмениваться друг с другом
информацией или чем-то еще. Вы – клиентская часть. Официант, повар и
холодильник – серверная часть.</p><br>

<p><b>&bull; Слоистая
архитектура.</b> Клиентов и серверов может быть много. Промежуточные элементы
являются как клиентом для своего сервера, так и сервером для своего клиента.
Каждый клиент может общаться только со своим сервером, а сервер – только со
своим клиентом. Клиент не может общаться с сервером своего сервера. Помните,
повар не принесет Вам жаркое лично.</p><br>

<p><b>&bull; Единый
интерфейс.</b> Способ общения компонентов обозначен определенным стандартом,
манерами поведения.</p><br>

<p><b>&bull; Никто не хранит
состояние.</b> Новый сеанс общения – чистый лист.</p><br>

<p><b>&bull; Кэширование.</b>
Всё-таки какую-то часто используемую информацию хранить можно.</p><br>

<p><b>&bull; Код по запросу.</b>
Если нужно выполнить сценарий на стороне клиента, можно предоставить ему для
этого все необходимое, пускай выполняет…</p><br>

<br>

<p>Итак, система REST
– это распределённое в сети приложение, спроектированное согласно кодексу  REST. Хоть кодекс – это не свод жёстких законов, а правила,
нарушать их нельзя. Есть только одно не обязательное к исполнению правило – код
по запросу.</p>

<br>
<br>

<p class="img_src"><img src="../src/img/art_rest/image004.jpg"></p>
<p class="img_desc"> - Кто еще хочет нарушить кодекс?</p>

<br>
<br>

<p>Теперь обладая общими
представлениями о REST, Вы можете приступить к изучению
технической документации по этой теме, чтобы понимать работу системы в реальных
ситуациях.</p>

<br>
<br>
<br>
<br>

</div>


<script src="../src/js/menu_btn.js"></script>
</body>
</html>